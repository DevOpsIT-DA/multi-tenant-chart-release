{{- if .Values.aws.ecr.enabled }}
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: ecr-secret-updater
  labels:
    {{- include "tenant-stack.labels" . | nindent 4 }}
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: secret-manager
  labels:
    {{- include "tenant-stack.labels" . | nindent 4 }}
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get", "create", "update", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: ecr-secret-manager
  labels:
    {{- include "tenant-stack.labels" . | nindent 4 }}
subjects:
- kind: ServiceAccount
  name: ecr-secret-updater
roleRef:
  kind: Role
  name: secret-manager
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: aws-ecr-credentials-updater
  labels:
    {{- include "tenant-stack.labels" . | nindent 4 }}
spec:
  schedule: "{{ .Values.aws.ecr.cronSchedule }}"
  successfulJobsHistoryLimit: 1
  failedJobsHistoryLimit: 1
  concurrencyPolicy: Replace
  jobTemplate:
    spec:
      backoffLimit: 3
      template:
        spec:
          serviceAccountName: ecr-secret-updater
          containers:
          - name: ecr-cred-helper
            image: {{ .Values.aws.ecr.helperImage }}
            env:
            - name: AWS_ACCESS_KEY_ID
              value: "{{ .Values.aws.ecr.accessKey }}"
            - name: AWS_SECRET_ACCESS_KEY
              value: "{{ .Values.aws.ecr.secretKey }}"
            - name: AWS_REGION
              value: "{{ .Values.aws.ecr.region }}"
            - name: AWS_ACCOUNT_ID
              value: "{{ .Values.aws.ecr.registryId }}"
            - name: SECRET_NAME
              value: "aws-ecr-credentials"
            command:
            - /bin/sh
            - -c
            - |
              set -e
              TOKEN=$(aws ecr get-login-password)
              AUTH=$(echo -n "AWS:$TOKEN" | base64)
              DOCKER_CONFIG="{\"auths\":{\"${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com\":{\"auth\":\"${AUTH}\"}}}"
              ENCODED_CONFIG=$(echo -n $DOCKER_CONFIG | base64 -w 0)
              
              # Check if secret exists
              if kubectl get secret $SECRET_NAME &>/dev/null; then
                kubectl patch secret $SECRET_NAME -p "{\"data\":{\".dockerconfigjson\":\"${ENCODED_CONFIG}\"}}"
                echo "Secret $SECRET_NAME updated"
              else
                kubectl create secret docker-registry $SECRET_NAME --docker-server="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com" --docker-username=AWS --docker-password="${TOKEN}"
                echo "Secret $SECRET_NAME created"
              fi
          restartPolicy: OnFailure
---
# Create initial secret to use until CronJob runs for the first time
apiVersion: v1
kind: Secret
metadata:
  name: aws-ecr-credentials
  labels:
    {{- include "tenant-stack.labels" . | nindent 4 }}
  annotations:
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-weight": "-5"
type: kubernetes.io/dockerconfigjson
data:
  .dockerconfigjson: {{ printf "{\"auths\":{\"%s.dkr.ecr.%s.amazonaws.com\":{\"auth\":\"%s\"}}}" .Values.aws.ecr.registryId .Values.aws.ecr.region (printf "AWS:%s" "dummy-token" | b64enc) | b64enc }}
{{- end }}
